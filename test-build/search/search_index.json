{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the documentation page for libtropic, the official C library for the TROPIC01 secure element.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>This documentation has the following structure:</p> <ul> <li>Get Started: All the things you will need to get started with libtropic.</li> <li>Examples: After getting started, dive into our example programs, showing a basic libtropic usage.</li> <li>Tests: To see how we test, see our functional and unit tests.</li> <li>For Developers: If you need more information on libtropic to start developing or contributing.</li> <li>Other: Even more information about libtropic.</li> <li>API Reference: Detailed lbtropic API documentation generated with Doxygen.</li> </ul>"},{"location":"#getting-tropic01","title":"Getting TROPIC01","text":"<p>TROPIC01 is currently available in several form factors - check out the TROPIC01 repository, where you can find datasheets, documentation and ordering instructions.</p>"},{"location":"#platform-repositories","title":"Platform Repositories","text":"<p>We offer so-called platform repositories, where libtropic is utilized as a submodule, possibly showing an example of integrating libtropic into your application:</p> <ul> <li>libtropic-stm32,</li> <li>libtropic-linux.</li> </ul> <p>All of these repositories consist of:</p> <ul> <li>libtropic as a git submodule,</li> <li>directories for supported platforms:<ul> <li><code>CMakeLists.txt</code>,</li> <li>include directory,</li> <li>source directory with <code>main.c</code>,</li> <li>additional files (readme, scripts, ...).</li> </ul> </li> </ul> <p>For more detailed info, refer to the aforementioned platform repositories.</p> <p>Beside these platform repositories, we offer the libtropic-util repository, which implements a CLI based utility for executing TROPIC01's commands.</p>"},{"location":"doxygen/mainpage/","title":"Introduction","text":"<p>Welcome to the documentation of the libtropic API, the official C library for the TROPIC01 secure element.</p> <p>For more information about libtropic, refer to the libtropic repository.</p>"},{"location":"examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains multiple examples demonstrating how to use libtropic.</p> <p>Some examples may cause irreversible changes to the chip, so they are organized into two categories:</p> <ul> <li>Reversible Examples,</li> <li>Irreversible Examples.</li> </ul> <p>Note</p> <p>Examples are not compiled by default. To compile examples, either</p> <ul> <li>pass <code>-DLT_BUILD_EXAMPLES=1</code> to <code>cmake</code> during compilation, or</li> <li>in your CMake file, switch this option on: <code>set(LT_BUILD_EXAMPLES ON)</code>.</li> </ul> <p>Note</p> <p>During build, SH0 keypair is automatically chosen from <code>libtropic/provisioning_data/&lt;lab_batch_package_directory&gt;/sh0_key_pair/</code>, this SH0 key is present in the majority of distributed TROPIC01 chips. In certain cases (first engineering samples) it might be necessary to manually set it (in PEM or DER format) with following cmake switch: <code>-DLT_SH0_PRIV_PATH=&lt;path to sh0_priv_engineering_sample01.pem&gt;</code>.</p>"},{"location":"examples/irreversible_examples/","title":"Irreversible Examples","text":"<p>Bug</p> <p>Add more info.</p> <p>List of irreversible examples.</p>"},{"location":"examples/irreversible_examples/#lt_ex_hw_walletc","title":"lt_ex_hw_wallet.c","text":"<p>Shows how to use configuration objects and different pairing keys to manage access to TROPIC01 features. We used a hardware wallet device scenario as a model for this example.</p>"},{"location":"examples/irreversible_examples/#lt_ex_fw_updatec","title":"lt_ex_fw_update.c","text":"<p>Explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application.</p>"},{"location":"examples/reversible_examples/","title":"Reversible Examples","text":"<p>Bug</p> <p>Add more info.</p> <p>List of reversible examples.</p>"},{"location":"examples/reversible_examples/#lt_ex_hello_worldc","title":"lt_ex_hello_world.c","text":"<p>A basic example to verify chip functionality and establish a secured session.</p>"},{"location":"examples/reversible_examples/#lt_ex_hello_world_separate_apic","title":"lt_ex_hello_world_separate_API.c","text":"<p>Functionally similar to <code>lt_ex_hello_world.c</code>, but uses distinct API calls for incoming and outgoing data. This approach is useful for secure, tunneled communication, used for example during chip provisioning in a factory.</p>"},{"location":"examples/reversible_examples/#lt_ex_show_chip_id_and_fw_verc","title":"lt_ex_show_chip_id_and_fw_ver.c","text":"<p>Demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions).</p>"},{"location":"examples/reversible_examples/#lt_ex_macanddc","title":"lt_ex_macandd.c","text":"<p>Illustrates the MAC-and-destroy feature. Refer to the application note and code comments for details.</p>"},{"location":"for_developers/","title":"For Developers","text":"<p>This section is for those who want to start developing with libtropic.</p> <ul> <li>Adding a New Embedded Platform</li> <li>Adding a New Cryptographic Backend</li> <li>Randomization</li> <li>Run Static Analysis</li> <li>Code Formatter</li> </ul>"},{"location":"for_developers/adding_crypto_backend/","title":"Adding a New Cryptographic Backend","text":"<p>As libtropic was designed with extensibility in mind, it is possible to add a new backend for the cryptographic operations.</p>"},{"location":"for_developers/adding_crypto_backend/#requirements","title":"Requirements","text":"<p>The new cryptographic backend has to support the following schemes:</p> <ul> <li>AES (GCM)<ul> <li>encryption</li> <li>decryption</li> </ul> </li> <li>ECDSA<ul> <li>signing</li> </ul> </li> <li>ED25519<ul> <li>signing</li> </ul> </li> <li>SHA256<ul> <li>hashing</li> </ul> </li> <li>Curve25519<ul> <li>multiplication on both arbitrary and base point</li> </ul> </li> </ul> <p>Bug</p> <p>Is this all? What about the whole certificate chain verification?</p>"},{"location":"for_developers/adding_crypto_backend/#guide","title":"Guide","text":"<p>To add a new cryptographic backend (let's say <code>mycrypto</code>), Create and Implement the Necessary Files first and then Edit the Main CMakeLists.txt.</p>"},{"location":"for_developers/adding_crypto_backend/#create-and-implement-the-necessary-files","title":"Create and Implement the Necessary Files","text":"<ol> <li>Inside <code>hal/crypto/</code>, create a new directory called <code>mycrypto</code>.</li> <li>Inside <code>hal/crypto/mycrypto/</code>, create 5 new source files:<ul> <li><code>lt_crypto_mycrypto_aesgcm.c</code>,</li> <li><code>lt_crypto_mycrypto_ecdsa.c</code>,</li> <li><code>lt_crypto_mycrypto_ed25519.c</code>,</li> <li><code>lt_crypto_mycrypto_sha256.c</code>,</li> <li><code>lt_crypto_mycrypto_x25519.c</code>.</li> </ul> </li> <li> <p>In each of the source files, implement all required functions - they are declared in respective headers inside the <code>src/</code> directory:</p> <ul> <li><code>lt_aesgcm.h</code>: AES-GCM functions,</li> <li><code>lt_ed25519.h</code>: ED25519 functions,</li> <li><code>lt_sha256.h</code>: SHA256 functions,</li> <li><code>lt_x25519.h</code>: Curve25519 functions.</li> </ul> <p>Look into each header - the exact purpose of every function is described in its comment. Copy the function declarations from the headers to the source files and implement the functions.</p> <p>Example</p> <p>To implement Curve25519 functions, I will copy declarations from the <code>lt_x25519.h</code> to <code>lt_crypto_mycrypto_x25519.c</code> and provide implementations. You can use existing ports inside <code>hal/crypto/</code> for inspiration.</p> </li> </ol>"},{"location":"for_developers/adding_crypto_backend/#edit-the-main-cmakeliststxt","title":"Edit the Main CMakeLists.txt","text":"<p>Bug</p> <p>We have options <code>LT_USE_TREZOR_CRYPTO</code> and <code>LT_CRYPTO_MBEDTLS</code>. We should unite the naming.</p> <ol> <li>In the <code>Setup</code> section of the <code>CMakeLists.txt</code> file at the top, add a new option for the added cryptographic backend <code>mycrypto</code>: <pre><code>option(LT_CRYPTO_MYCRYPTO \"Use mycrypto as a cryptography provider\" OFF)\n</code></pre></li> <li>In the end of the <code>Setup</code> section, there are checks for definition of the cryptographic backend, because one of the backends has to be always defined. Add a check for the new option <code>LT_CRYPTO_MYCRYPTO</code>: <pre><code># Check if cryptography provider is defined\n# Check if cryptography provider is defined\nif(\n    (NOT LT_CRYPTO_&lt;crypto_backend1&gt;)  AND\n    (NOT LT_CRYPTO_&lt;crypto_backend2&gt;)  AND\n    (NOT LT_CRYPTO_MYCRYPTO)     # &lt;-- YOUR NEW OPTION HERE\n)\n    message(FATAL_ERROR \"No cryptography provider is defined.\")\nendif()\n</code></pre></li> <li>In the <code>Collect files</code> section, add the new source files to the compilation process. Use the following template, modify it accordingly, and paste it above the <code># --- add new crypto sources above this line ---</code> comment: <pre><code>set(SDK_SRCS ${SDK_SRCS}\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_aesgcm.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_ed25519.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_ecdsa.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/hal/crypto/mycrypto/lt_crypto_mycrypto_x25519.c\n)\n</code></pre></li> <li>In the <code>Compile and link</code> section, compile and link dependencies to your new crypto backend: <pre><code>if(LT_CRYPTO_MYCRYPTO)\n    add_subdirectory(vendor/mycrypto/ \"mycrypto\")\n    target_compile_definitions(mycrypto PRIVATE &lt;edit_me&gt;) # Edit or remove.\n    target_compile_definitions(tropic PRIVATE LT_CRYPTO_MYCRYPTO)\n    target_link_libraries(tropic PRIVATE mycrypto)\n    # Add more lines if necessary.\nendif()\n</code></pre></li> </ol>"},{"location":"for_developers/adding_embedded_platform/","title":"Adding a New Embedded Platform","text":"<p>Bug</p> <p>Redo this, add more info, similarly to Adding a New Cryptographic Backend.</p> <p>To add a new embedded platform, follow these steps:</p> <ol> <li>Implement the necessary HAL (Hardware Abstraction Layer) functions, according to <code>include/libtropic_port.h</code></li> <li>Test the integration by compiling hello world example within your project</li> </ol> <p>For more inspiration check out our Integration examples.</p>"},{"location":"for_developers/code_formatter/","title":"Code Formatter","text":"<p>For the code formatting, we use the <code>clang-format</code> tool. Its installation varies dependening on the linux distribution.</p> <p>To check if <code>clang-format</code> is available on your machine, run: <pre><code>clang-format --version\n</code></pre></p> <p>We use <code>clang-format</code> to check code format on pushes and PRs into the master and develop branches - this is implemented in the action <code>.github/clang_format_check.yml</code>. It only checks the format and does not fix it - that is the contributor's responsibility.</p>"},{"location":"for_developers/code_formatter/#how-to-use-it","title":"How to Use It","text":"<p>There are multiple ways to format the code using <code>clang-format</code>:</p> <ol> <li>For each file with wrong formatting, run: <pre><code>clang-format -i &lt;path_to_the_file_to_format&gt;\n</code></pre></li> <li>If you are using VSCode and the <code>cpptools</code> extension, you can create <code>.vscode/settings.json</code> with the following contents (if it does not already exist): <pre><code>{ // Add this bracket only if your settings.json file is empty\n    \"[c]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    }\n} // Add this bracket only if your settings.json file is empty\n</code></pre> This will format the file on each save.</li> <li>There is also the <code>git-clang-format</code> tool, which integrates <code>clang-format</code> with <code>git</code>, but we have not used that yet.</li> <li>Possibly other ways...</li> </ol>"},{"location":"for_developers/randomization/","title":"Randomization","text":"<p>Bug</p> <p>Redo this? This does not talk about the randomization for functional testing.</p> <p>Some tests use a rudimentary randomization mechanism using standard C functions. The PRNG is normally seeded with current time. Used seed is always printed to stdout. You can find the seed in logs (<code>build/gcov/results/...</code>).</p> <p>To run tests with fixed seed, set <code>RNG_SEED</code> parameter to your desired seed (either directly in the file, or in the project.yml section <code>:defines:</code>). This is useful mainly to replicate a failed test run -- just find out what seed was used and then set <code>RNG_SEED</code> to this.</p>"},{"location":"for_developers/static_analysis/","title":"Run Static Analysis","text":"<p>Bug</p> <p>Redo this.</p> <p>To run static analysis, follow these steps:</p> <ol> <li>Choose a static analysis tool (e.g., cppcheck, clang-tidy).</li> <li>Configure the tool to analyze the library code.</li> <li>Run the analysis and review the reported issues.</li> </ol>"},{"location":"get_started/","title":"Get Started","text":"<p>Bug</p> <p>Besides these sections, I would add/integrate something like \"Why Use Libtropic?\" or \"What is Libtropic?\". Then something about the directory structure, API, HALs (basic information, the porting guides are in For Developers) and so on. Maybe a step by step what to do after cloning the repository.</p> <p>This section provides information to help you get started with using libtropic.</p> <ul> <li>Libtropic Architecture</li> <li>Adding Libtropic to an Existing Project</li> <li>Compile Libtropic as a Static Archive</li> <li>Logging</li> <li>Debugging</li> </ul> <p>After you get started, we recommend diving into our Examples.</p>"},{"location":"get_started/adding_to_project/","title":"Adding Libtropic to an Existing Project","text":"<p>We recommend adding libtropic to an existing project as a git submodule. Libtropic uses CMake build system, therefore it could be added to compilation of existing CMake projects in a following way:</p> <pre><code># Your CMakeLists.txt file\n\n# Set path of to the libtropic submodule\nset(PATH_LIBTROPIC \"libtropic/\")\n\n# This switch will expose not only core library functions, but also helper functions (recommended)\nset(LT_HELPERS ON)\n\n# These switches add functional tests and examples to the build process.\n# Might be a good starting point. Comment out if not needed.\nset(LT_BUILD_EXAMPLES ON)\nset(LT_BUILD_TESTS ON)\n\n# It is necessary to set provider of cryptography functions.\n# You can use trezor_crypto as the cryptography provider.\nset(LT_USE_TREZOR_CRYPTO ON)\n\n# Add path to the libtropic's repository root folder\nadd_subdirectory(${PATH_LIBTROPIC} \"libtropic\")\n\n# Linking\ntarget_link_options(produced_binary PRIVATE &lt;your_linker_flags&gt;)\n</code></pre> <p>Note</p> <p>The exact CMake calls depend on a configuration of the project into which libtropic is being added. For more inspiration, refer to the Platform Repositories section.</p> <p>Note</p> <p>We offer multiple CMake options - to see all of them, go to the beginning of the <code>CMakeLists.txt</code> file in the repository's root directory.</p>"},{"location":"get_started/adding_to_project/#do-you-use-makefile-instead-of-cmake","title":"Do You Use Makefile Instead of CMake?","text":"<p>In this case, you have to list all libtropic <code>*.c</code> and <code>*.h</code> files manually inside your Makefile and then for every CMake option you need (located in the libtropic's root <code>CMakelists.txt</code>), you add the <code>-D</code> switch when building with Make. The same has to be done for the cryptographic provider library, for example in <code>vendor/trezor_crypto/</code>.</p>"},{"location":"get_started/compile_as_static_archive/","title":"Compile Libtropic as a Static Archive","text":"<p>When compiling libtropic as a static archive, a cryptography provider must always be defined, either in your CMakeLists.txt file or via the CMake command line arguments.</p> <p>To compile <code>libtropic</code> as a static archive on an Unix-like system, do:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake -DLT_USE_TREZOR_CRYPTO=1 .. # providing the crypto backend\n$ make\n</code></pre> <p>To cross-compile <code>libtropic</code> as a static archive on an Unix-like system, do:</p> <pre><code>$ mkdir build\n$ cd build\n$ cmake -DLT_USE_TREZOR_CRYPTO=1 -DCMAKE_TOOLCHAIN_FILE=&lt;ABSOLUTE PATH&gt;/toolchain.cmake -DLINKER_SCRIPT=&lt;ABSOLUTE PATH&gt;/linker_script.ld ..\n$ make\n</code></pre>"},{"location":"get_started/debugging/","title":"Debugging","text":"<p>Bug</p> <p>Add more info.</p> <p>For compiling in debug mode replace <code>cmake ..</code> with <code>cmake -DCMAKE_BUILD_TYPE=Debug ..</code> (this will allow to step through with a debugger).</p>"},{"location":"get_started/libtropic_architecture/","title":"Libtropic Architecture","text":"<p>Bug</p> <p>Add more info?</p> <p>Libtropic is a standalone library expected to be used within a parent project.</p> <p>The following figure depicts libtropic's architecture:</p> <p>Bug</p> <p>The figure includes outdated information. </p> <p></p>"},{"location":"get_started/logging/","title":"Logging","text":"<p>Libtropic contains a logging functionality, which is disabled by default (unless you compile tests or examples).</p> <p>You may find it useful to enable logging during libtropic evaluation or integration. There are five logging levels:</p> <ul> <li>none (default unless compiling tests or examples),</li> <li>error,</li> <li>warning,</li> <li>info,</li> <li>debug.</li> </ul> <p>One of these logging levels can be switched on using the CMake switch <code>-DLT_LOG_LVL</code>, which is passed to <code>cmake</code> when building the project. The following table summarizes all logging levels and a switch corresponding to each level:</p> Level CMake switch none <code>-DLT_LOG_LVL=None</code> error <code>-DLT_LOG_LVL=Error</code> warning <code>-DLT_LOG_LVL=Warning</code> info <code>-DLT_LOG_LVL=Info</code> debug <code>-DLT_LOG_LVL=Debug</code>"},{"location":"get_started/logging/#how-to-log","title":"How to Log","text":"<p>Logging can be done using logging macros, which are defined in <code>include/libtropic_logging.h</code>. Following logging macros are available:</p> <ul> <li><code>LT_LOG_INFO</code>,</li> <li><code>LT_LOG_WARN</code>,</li> <li><code>LT_LOG_ERROR</code>,</li> <li><code>LT_LOG_DEBUG</code>.</li> </ul> <p>Each macro corresponds to a verbosity level, which is activated with the aforementioned CMake switch. Macros have the same interface as the <code>printf</code> function, as they are essentially a wrapper over <code>printf</code>.</p> <p>Important</p> <p>Avoid passing function calls as macro arguments (except for simple formatting helpers like <code>lt_ret_verbose</code> or <code>strerror</code>). Logging macros may be completely removed at lower verbosity levels, meaning any function calls inside them will not execute.</p> <p>This is safe (using <code>lt_ret_verbose()</code> helper function only):</p> <pre><code>LT_LOG_INFO(\"Error code: %d, error string: %s\", ret, lt_ret_verbose(ret));\n</code></pre> <p>This is unsafe \u2014 <code>lt_init()</code> will never run if logging is disabled:</p> <pre><code>LT_LOG_INFO(\"Initializing handle: %d\", lt_init(&amp;h));\n</code></pre> <p>Correct approach \u2014 call the function first, then log its result:</p> <pre><code>int ret = lt_init(&amp;h);\nLT_LOG_INFO(\"Initializing handle: %d\", ret);\n</code></pre> <p>Note</p> <p>There are also macros used for assertion. These are used in functional tests.</p>"},{"location":"other/","title":"Other","text":"<p>This section provides more information about libtropic, which did not fit into the other sections.</p> <ul> <li>TROPIC01 Model</li> <li>Provisioning Data</li> </ul>"},{"location":"other/provisioning_data/","title":"Provisioning Data","text":"<p>The <code>provisioning_data/</code> directory contains so called lab batch packages, which are data used for prsovisioning TROPIC01 chips in the Tropic Square lab for testing purposes. These lab batch packages are used here for configuring the TROPIC01 Model and for providing the tests and examples public and private keys for the TROPIC01's pairing key slot 0 (SH0PUB, SH0PRIV), so they can establish a secure session with the chip. </p> <p>Note</p> <p>Lab batch packages in this directory are stripped - they contain only data needed in libtropic.</p>"},{"location":"other/provisioning_data/#lab-batch-package-contents","title":"Lab Batch Package Contents","text":"<p>For example, the <code>2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/</code> lab batch package:</p> <ol> <li><code>cert_chain/</code>: All certificates for the Certificate Store (excluding TROPIC01's eSE device certificate, which is originally not part of the lab batch package - can be found outside the <code>cert_chain/</code> directory).</li> <li><code>i_config/</code>, <code>r_config/</code>: Contains fields which should be written - currently not used.</li> <li><code>sh0_key_pair/</code>: Contains public and private key for the pairing key slot 0 (SH0PUB, SH0PRIV).</li> <li><code>tropic01_ese_certificate.pem</code>: TROPIC01's eSE device certificate.</li> <li><code>tropic01_ese_private_key.pem</code>: TROPIC01's eSE device private key (STPRIV).</li> </ol>"},{"location":"other/tropic01_model/","title":"TROPIC01 Model","text":"<p>Code in the <code>tropic01_model/</code> directory is meant to be compiled under Unix-like OS. This directory offers running libtropic's functional tests and examples against the TROPIC01's Python model, so no chip or external hardware is needed.</p> <ul> <li>Functional testing is managed by CTest - it executes both the test and the model automatically, along with the creation of model configuration.</li> <li>When running examples, you need to start the model manually and then execute the example binary in a separate terminal. This applies also for the tests, if they are not run using CTest.</li> <li>Both of these points are discussed further in this text.</li> </ul> <p>Warning</p> <p>There are some examples which are not compatible with model, as the model does not implement all the chip's functionality. As such, those will always fail against the model. Namely:</p> <ul> <li><code>lt_ex_fw_update</code>.</li> </ul>"},{"location":"other/tropic01_model/#how-it-works","title":"How it Works?","text":"<p>Both processes (tests/examples and model) will talk to each other through TCP socket at 127.0.0.1:28992. The SPI layer between libtropic and model is emulated through this TCP connection. The model responses are exactly the same as from physical TROPIC01 chip. </p> <p>Note</p> <p>This functionality is implemented with the help of the Unix TCP HAL implemented in <code>hal/port/unix/lt_port_unix_tcp.c</code>.</p>"},{"location":"other/tropic01_model/#model-setup","title":"Model Setup","text":"<p>First, the model has to be installed. For that, follow the readme in the ts-tvl repository.</p> <p>Next, it is possible to initialize the model with some data, so it can behave like the real provisioned chip. To do that, it is neccesary to pass a YAML configuration file to the model - see sections Model Server and Model Configuration in the ts-tvl repository. To create such a YAML configuration, the script <code>tropic01_model/create_model_cfg.py</code> in libtropic repository is used (example usage follows).</p> <p>Important</p> <p>In the case of running tests using CTest, no manual steps for creating the model configuration or initializing the model are necessary - CTest handles this by itself. In the case of running examples (or tests without CTest), the model has to be started manually by the user and some configuration has to be applied to the model, so atleast the pairing key slot 0 is written to be able to establish a secure session.</p> <p>Data, from which the <code>tropic01_model/create_model_cfg.py</code> script creates the YAML configuration file for the model, can be found in <code>provisioning_data/</code> directory - see Provisioning Data section for more information about the directory structure.</p> <p>To create a model configuration that will initialize the model to the state which is almost identical to the provisioned chip, the <code>tropic01_model/create_model_cfg.py</code> script is run as: <pre><code>cd tropic01_model/\npython3 create_model_cfg.py --pkg-dir &lt;path_to_the_lab_batch_package_directory&gt;\n</code></pre> where <code>&lt;path_to_the_lab_batch_package_directory&gt;</code> is the path to one of the lab batch packages inside the <code>provisioning_data/</code>. As a result of running the script, a file <code>model_cfg.yml</code> is created, which can be passed directly to the model using the <code>-c</code> flag.</p>"},{"location":"other/tropic01_model/#running-the-examples","title":"Running the Examples","text":"<ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the examples: <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_EXAMPLES=1 ..\nmake\n</code></pre> As a result, executables for each example are built in the <code>tropic01_model/build/</code> directory. </p> <p>Tip</p> <p>To enable debugging symbols (e.g. to use GDB) and debug logging, add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> </li> <li> <p>Create a YAML configuration for the model from one of the lab batch packages: <pre><code>python3 ../create_model_cfg.py --pkg-dir ../../provisioning_data/2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/\n</code></pre> As a result, <code>model_cfg.yml</code> is created.</p> </li> <li> <p>In a separate terminal, start the model server (which was previously installed in a Python virtual environment) and configure it: <pre><code>model_server tcp -c model_cfg.yml\n</code></pre> As a result, the model now listens on TCP port 127.0.0.1:28992.</p> </li> <li> <p>In the original terminal, execute one of the built examples: <pre><code>./lt_ex_hello_world\n</code></pre> As a result, you should see an output from the example in the original terminal and a log from the model in the separate terminal.</p> </li> </ol>"},{"location":"other/tropic01_model/#running-the-tests","title":"Running the Tests","text":"<p>Note</p> <p>It is recommended to run the tests using CTest, but if it's needed to run the tests under GDB, they can be run exactly the same way as the examples.</p> <ol> <li>Switch to the <code>tropic01_model/</code> directory: <pre><code>cd tropic01_model/\n</code></pre></li> <li> <p>Compile the tests in this directory: <pre><code>mkdir build\ncd build\ncmake -DLT_BUILD_TESTS=1 ..\nmake\n</code></pre> As a result, executables for each test are built in the <code>tropic01_model/build/</code> directory. </p> <p>Tip</p> <p>To enable debugging symbols (e.g. to use GDB) and debug logging, add switch <code>-DCMAKE_BUILD_TYPE=Debug</code> when executing <code>cmake</code>.</p> <p>To use AddressSanitizer (ASan), add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code> when executing <code>cmake</code>.</p> <p>To execute the tests with Valgrind, add switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_VALGRIND=1</code> when executing <code>cmake</code>. Note that Valgrind will be executed automatically only when using CTest!</p> </li> <li> <p>Now, the tests can be run using CTest. To see available tests, run: <pre><code>ctest -N\n</code></pre> To select specific test(s) using regular expression, run: <pre><code>ctest -R &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> </li> </ol> <p>To run all tests, simply run: <pre><code>ctest\n</code></pre> </p> <p>Tip</p> <p>To enable verbose output from CTest, run <code>ctest -V</code> or <code>ctest -W</code> switch for even more verbose output.</p> <p>To exclude some tests, run: <pre><code>ctest -E &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> <p>After CTest finishes, it informs about the results and saves all output to the <code>tropic01_model/build/run_logs/</code> directory. Output from the tests and responses from the model are saved. </p> <p>Note</p> <p>The model is automatically started for each test separately, so it behaves like a fresh TROPIC01 straight out of factory. All this and other handling is done by the script <code>scripts/model_test_runner.py</code>, which is called by CTest.</p> <p>Important</p> <p>When <code>-DLT_BUILD_EXAMPLES=1</code> or <code>-DLT_BUILD_TESTS=1</code> are passed to CMake, there has to be a way to define the SH0 private key for the TROPIC01's pairing key slot 0, because both the examples and the tests depend on it. For this purpose, the CMake variable <code>LT_SH0_PRIV_PATH</code> is used, which should hold the path to the file with the SH0 private key in PEM or DER format. By default, the path is set to the currently used lab batch package, found in <code>../provisioning_data/&lt;lab_batch_package_directory&gt;/sh0_key_pair/</code>. But it can be overriden by the user either from the command line when executing CMake (switch <code>-DLT_SH0_PRIV_PATH=&lt;path&gt;</code>), or from a child <code>CMakeLists.txt</code>.</p>"},{"location":"tests/","title":"Tests","text":"<p>All tests are implemented in the <code>tests/</code> directory. There are two groups of tests:</p> <ol> <li>Functional Tests (<code>tests/functional/</code>): tests for verifying the libtropic core API,</li> <li>Unit Tests (<code>tests/unit/</code>): basic checking of function arguments and return values using Ceedling, do not test correct functionality.</li> </ol> <p>In the <code>libtropic</code> repository, tests are run against the TROPIC01 model only - refer to TROPIC01 Model section for more information. Testing aganist the TROPIC01 model is also utilized in a CI job, triggered for the <code>master</code> and <code>develop</code> branches (pushes and pull requests).</p> <p>The tests can also be run in the libtropic platform repositories.</p>"},{"location":"tests/functional_tests/","title":"Functional Tests","text":"<p>Functional tests are implemented in <code>tests/functional_tests/</code>.</p> <p>Some tests may cause irreversible changes to the chip, so they are organized into two categories:</p> <ul> <li>reversible (<code>lt_test_rev_*.c</code>): only reversible operations are executed on the TROPIC01 chip,</li> <li>irreversible (<code>lt_test_ire_*.c</code>): irreversible operations are executed, so the TROPIC01 chip may get bricked.</li> </ul> <p>Note</p> <p>Functional tests are not compiled by default. To compile functional tests, either</p> <ul> <li>pass <code>-DLT_BUILD_TESTS=1</code> to <code>cmake</code> during compilation, or</li> <li>in your CMake file, switch the option on: <code>set(LT_BUILD_TESTS ON)</code>.</li> </ul> <p>Note</p> <p>During build, SH0 keypair is automatically chosen from <code>libtropic/provisioning_data/&lt;lab_batch_package_directory&gt;/sh0_key_pair/</code>, this SH0 key is present in the majority of distributed TROPIC01 chips. In certain cases (first   engineering samples) it might be necessary to manually set it (in PEM or DER format) with following cmake switch: <code>-DLT_SH0_PRIV_PATH=&lt;path to sh0_priv_engineering_sample01.pem&gt;</code></p>"},{"location":"tests/functional_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>To add a new test, you need to:</p> <ol> <li>Decide whether the test is reversible or not. See below.</li> <li>Write the new test. Use the template below.</li> <li>Add the declaration together with a Doxygen comment to <code>include/libtropic_functional_tests.h</code>.</li> <li>Add the test to the root <code>CMakeLists.txt</code>:<ul> <li>In the section \"LIBTROPIC FUNCTIONAL TESTS\", add the test name to the <code>LIBTROPIC_TEST_LIST</code>   (it has to be the same as the name of the function which implements the test)</li> <li>Below the <code>LIBTROPIC_TEST_LIST</code>, there is a section where <code>SDK_SRCS</code> is extended   with test source files. Add source file of your test here.</li> </ul> </li> <li>Make sure your test works. Use the model: check out TROPIC01 Model section. If the test    fails, you either:<ul> <li>Did a mistake in the test. Fix it.</li> <li>Or you found a bug -- if you are certain it is a bug and not a problem in your test,   open an issue. Thanks!</li> </ul> </li> </ol>"},{"location":"tests/functional_tests/#test-types-and-cleanup","title":"Test Types and Cleanup","text":"<p>As the tests are also ran against real chips, we recognize two types of tests:</p> <ol> <li>Reversible -- this type of test shall not make any irreversible changes to the chip. It may    happen that the test is interrupted by a failed assert. For this cases there is a possibility    to define a cleanup function, which is called on every failed assert before test termination.    Every test that do some changes which require cleanup afterwards for the test to be truly reversible    MUST contain the cleanup function.</li> <li>Irreversible -- this type of test causes changes which are not reversible by nature (e.g. I-config    modifications). Those test do not have to implement cleanup function, as the chip is always    \"destroyed\" after running the test.</li> </ol>"},{"location":"tests/functional_tests/#cleanup-function","title":"Cleanup Function","text":"<p>If the assert fails, the assert function checks whether the <code>lt_test_cleanup_function</code> function pointer is not <code>NULL</code>. If not, the cleanup function is called automatically before terminating the test. By default, the pointer is initialized to <code>NULL</code>.</p> <p>If you need cleanup function, please create the function and assign the <code>lt_test_cleanup_function</code> at the right moment in the test (e.g. after you backed up data you would like to restore).</p> <p>You can of course reuse your cleanup function at the end of the test, so you don't have to duplicate the cleanup code if it would be the same. If you wrap the function call in the <code>LT_TEST_ASSERT</code>, do not forget to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehands, otherwise the cleanup will be called twice.</p>"},{"location":"tests/functional_tests/#test-template","title":"Test Template","text":"<p>Change the lines with <code>TODO</code>.</p> <pre><code>/**\n * @file TODO: FILL ME\n * @brief TODO: FILL ME\n * @author Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_functional_tests.h\"\n#include \"libtropic_logging.h\"\n\n// Shared with cleanup function.\n// TODO: CAN BE REMOVED IF CLEANUP NOT USED.\nlt_handle_t *g_h;\n\n// TODO: REMOVE OR EDIT\nlt_ret_t lt_new_test_cleanup(void)\n{\n    LT_LOG_INFO(\"Starting secure session with slot %d\", (int)PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(g_h, sh0priv, sh0pub, PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to establish secure session, ret=%s\", lt_ret_verbose(ret));\n        return ret;\n    }\n\n    // TODO: REST OF THE CLEANUP DUTIES\n\n    return LT_OK;\n}\n\nvoid lt_new_test(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"----------------------------------------------\");\n    LT_LOG_INFO(\"lt_new_test()\");\n    LT_LOG_INFO(\"----------------------------------------------\");\n\n    // TODO/NOTE: If you use cleanup, do not forget to assign handle to a globally available pointer,\n    // so you can use the handle in the cleanup function.\n    g_h = h;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_init(h));\n\n    LT_LOG_INFO(\"Starting Secure Session with key %d\", (int)PAIRING_KEY_SLOT_INDEX_0);\n    LT_TEST_ASSERT(LT_OK, lt_verify_chip_and_start_secure_session(h, sh0priv, sh0pub, PAIRING_KEY_SLOT_INDEX_0));\n    LT_LOG_LINE();\n\n    // TODO: DO THE TESTING HERE\n    // Add this line if you need cleanup. Add it where appropriate -- e.g. after backing up data\n    // you need to restore in the cleanup.\n    lt_test_cleanup_function = &amp;lt_new_test_cleanup;\n\n    // Call cleanup function, but don't call it from LT_TEST_ASSERT anymore.\n    lt_test_cleanup_function = NULL;\n    LT_LOG_INFO(\"Starting post-test cleanup\");\n    LT_TEST_ASSERT(LT_OK, lt_new_test_cleanup());\n    LT_LOG_INFO(\"Post-test cleanup was successful\");\n}\n</code></pre>"},{"location":"tests/unit_tests/","title":"Unit Tests","text":"<p>Bug</p> <p>The unit tests are outdated and will be redone in the future.</p>"},{"location":"tests/unit_tests/#unit-tests","title":"Unit Tests","text":"<p>Check whether function itself are behaving as should.</p>"},{"location":"tests/unit_tests/#dependencies","title":"Dependencies","text":"<p>TODO</p>"},{"location":"tests/unit_tests/#test-organization","title":"Test Organization","text":"<p>TODO</p>"},{"location":"tests/unit_tests/#run-tests","title":"Run Tests","text":"<p>Unit tests files are in <code>tests/unit/</code> folder. They are written in Ceedling framework, install it like this:</p> <pre><code>    # Install Ruby\n    $ sudo apt-get install ruby-full\n\n    # Ceedling install\n    $ gem install ceedling\n\n    # Code coverage tool used by Ceedling\n    $ pip install gcovr\n</code></pre> <p>Then make sure that you have correct version: <pre><code>$ ceedling version\n   Ceedling:: 0.31.1\n      Unity:: 2.5.4\n      CMock:: 2.5.4\n CException:: 1.3.3\n</code></pre> For now we support Ceedling version 0.31.1 only.</p> <p>Once ceedling is installed, run tests and create code coverage report:</p> <pre><code>$ CEEDLING_MAIN_PROJECT_FILE=scripts/ceedling.yml ceedling gcov:all utils:gcov\n</code></pre>"}]}